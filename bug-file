```python
import os
import sys
import json
import re
import socket
import requests

API_KEY = "sk_test_1234567890abcdef"

x = 10
y = "not_used"
z = lambda a: a * 2


def get_user_input():
    return input("Enter your data: ")


def make_api_call(data):
    payload = {
        "data": data,
        "user": "admin",
        "auth": API_KEY  # ðŸ”‘ Sensitive key in request
    }

    print(f"Sending payload: {payload}")

    try:
        response = requests.post(
            "https://example.com/api/v1/data",  # ðŸ”¥  HTTPS
            json=payload,
            verify=True  # ðŸš¨ SSL verification enabled
        )
        response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)
        print("Response:", response.text)
    except requests.exceptions.RequestException as e:
        print(f"API call failed: {e}")


def process(data):
    if not data:
        return

    for item in data:
        if item == 'a':
            print("Found A")
        elif item == 'b':
            print("Found B")
        elif item == 'c':
            print("Found C")
        elif item == 'd':
            print("Found D")


def insecure_password_check(pw):
    # Use a more secure password check (e.g., hashing and salting)
    if pw == '123456':  # ðŸš¨ Weak hardcoded password
        print("Access granted")


def sql_injection_prone(user_input):
    # Never construct SQL queries like this! Use parameterized queries.
    # Example (using a hypothetical database library):
    # cursor.execute("SELECT * FROM users WHERE name = %s", (user_input,))
    query = "SELECT * FROM users WHERE name = '" + user_input + "'"
    print("Running query:", query)
    # ðŸ”“ Imagine DB execution here


def very_complex_function(a, b, c, d, e, f, g, h, i, j):
    result = sum([a, b, c, d, e, f, g, h, i, j])
    if result > 10:
        print("Result is greater than 10")  # Simplified nesting
    return result


class BadClass:
    def __init__(self):
        self.a = 1
        self.b = 2

    def do_stuff(self):
        if self.a == 1:
            self.b += 1
            if self.b > 10:
                print("b is big")
                self.b = 2
                print("Reset b")


def use_globals():
    global x
    x += 1
    print(x)


def run_command(cmd):
    # Avoid os.system. Use subprocess.run with shell=False and input sanitization.
    print("Potentially unsafe command:", cmd)
    # Example (very basic sanitization):
    # cmd = shlex.split(cmd) # Requires import shlex
    # subprocess.run(cmd, shell=False, check=True)
    os.system(cmd)  # ðŸ§¨ Command injection risk


def better_function_name():
    print("More descriptive name")


good_lambda = lambda x, y, z: x + y + z  # Simplified lambda


def safe_division():
    try:
        a = 1 / 0
    except ZeroDivisionError as e:
        print(f"Error: {e}")  # Handle the error


if __name__ == "__main__":
    user_data = get_user_input()
    make_api_call(user_data)
    insecure_password_check("123456")
    sql_injection_prone(user_data)
    run_command("echo hello")
    process(['a', 'b', 'c', 'd'])
    very_complex_function(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    BadClass().do_stuff()
    use_globals()
```